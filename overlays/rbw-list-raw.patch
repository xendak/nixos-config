commit 3e67f181251219066380c8355444a1e51d5f0526 (HEAD -> main)
Author: xendak <108767275+xendak@users.noreply.github.com>
Date:   Wed Sep 24 20:48:44 2025 -0300

feat(commands): get notes & uris for list --raw

---
src/bin/rbw/commands.rs | 41 ++++++++++++++++++++++++++++++++
1 file changed, 41 insertions(+)

diff --git a/src/bin/rbw/commands.rs b/src/bin/rbw/commands.rs
index bb49cf2..169c958 100644
--- a/src/bin/rbw/commands.rs
+++ b/src/bin/rbw/commands.rs
@@ -54,6 +54,8 @@ struct DecryptedListCipher {
     name: Option<String>,
     user: Option<String>,
     folder: Option<String>,
+    notes: Option<String>,
+    uris: Vec<(String, Option<rbw::api::UriMatchType>)>,
 }
 
 #[derive(Debug, Clone, serde::Serialize)]
@@ -194,6 +196,8 @@ impl From<DecryptedSearchCipher> for DecryptedListCipher {
             name: Some(value.name),
             user: value.user,
             folder: value.folder,
+            notes: value.notes,
+            uris: value.uris,
         }
     }
 }
@@ -1840,6 +1844,41 @@ fn decrypt_list_cipher(
     } else {
         None
     };
+    let notes = entry
+        .notes
+        .as_ref()
+        .map(|notes| {
+            crate::actions::decrypt(
+                notes,
+                entry.key.as_deref(),
+                entry.org_id.as_deref(),
+            )
+        })
+        .transpose();
+    let notes = match notes {
+        Ok(notes) => notes,
+        Err(e) => {
+            log::warn!("failed to decrypt notes: {e}");
+            None
+        }
+    };
+
+    let uris = if let rbw::db::EntryData::Login { uris, .. } = &entry.data {
+        uris.iter()
+            .filter_map(|s| {
+                decrypt_field(
+                    "uri",
+                    Some(&s.uri),
+                    entry.key.as_deref(),
+                    entry.org_id.as_deref(),
+                )
+                .map(|uri| (uri, s.match_type))
+            })
+            .collect()
+    } else {
+        vec![]
+    };
+
     let folder = if fields.contains(&ListField::Folder) {
         // folder name should always be decrypted with the local key because
         // folders are local to a specific user's vault, not the organization
@@ -1857,6 +1896,8 @@ fn decrypt_list_cipher(
         name,
         user,
         folder,
+        notes,
+        uris,
     })
 }
 
